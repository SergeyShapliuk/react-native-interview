ОГЛАВЛЕНИЕ
Архитектура React Native (Bridge, JSI, Hermes)
Производительность и Оптимизация (FlatList, Рендеры, Память)
Управление Состоянием (Redux, Context, Server State)
Нативная Разработка и Сборка (iOS, Android, Modules)
Тестирование и CI/CD
Безопасность и Troubleshooting
=========================================================================
АРХИТЕКТУРА REACT NATIVE
В: Как работает React Native и что такое "Мост" (Bridge)?
О: React Native работает на основе взаимодействия двух основных потоков: потока JavaScript (где выполняется бизнес-логика и React) и основного нативного потока (UI Thread, где происходит отрисовка на экране). В классической архитектуре они общаются через асинхронный канал связи — "Мост" (Bridge). Данные передаются через него в сериализованном виде (JSON). Когда вы меняете состояние в приложении, JS отправляет через мост команду нативной стороне: "создай виджет с такими параметрами". Проблема моста в том, что сериализация и передача данных занимают время. При высокой нагрузке (быстрый скролл, сложные анимации) мост становится "узким горлышком", сообщения накапливаются в очереди, и интерфейс начинает тормозить. В новой архитектуре (Fabric) мост устранен благодаря JSI (JavaScript Interface), что позволяет JS коду напрямую обращаться к нативным объектам на C++ синхронно, что значительно повышает производительность.
В: Что такое Hermes и зачем он нужен?
О: Hermes — это движок JavaScript, разработанный специально для React Native. В отличие от стандартного движка (JSC), который компилирует код во время выполнения приложения (Just-in-Time), Hermes компилирует код в байт-код еще на этапе сборки приложения на компьютере разработчика (Ahead-Of-Time). Это дает три главных преимущества: во-первых, приложение запускается гораздо быстрее, так как телефону не нужно тратить время на первоначальную компиляцию текста скрипта. Во-вторых, оно занимает меньше оперативной памяти, что критично для бюджетных Android-устройств. В-третьих, уменьшается размер установочного файла. Для разработчика это означает более плавную работу приложения на старте и меньшее потребление ресурсов устройства.
В: В чем разница между Debug и Release сборками?
О: Debug сборка предназначена для разработки и отладки. Она запускается через Metro Bundler, подключается к отладчику (Flipper/Chrome), использует неизмененный JS код и часто работает на движке в режиме отладки, что медленнее. В ней отключены многие оптимизации, разрешены небезопасные соединения и включены подробные логи. Release сборка — это финальная версия для пользователей. В ней код минифицирован, обфусцирован (имена переменных изменены для защиты и уменьшения размера), включены все оптимизации компилятора (ProGuard на Android, LLVM на iOS) и используется оптимизированный байт-код Hermes. Баги могут проявляться только в Release из-за различий в скорости выполнения (проблемы синхронизации), работы обфускатора (если не настроены правила сохранения имен классов) или строгой политики безопасности сети, которая блокирует HTTP запросы в продакшене.
=========================================================================
2. ПРОИЗВОДИТЕЛЬНОСТЬ И ОПТИМИЗАЦИЯ
=========================================================================
В: Как оптимизировать производительность FlatList для больших списков?
О: FlatList — основной компонент для списков, но без настройки он может тормозить. Главное правило — рендерить только то, что видно на экране. Для этого нужно обязательно использовать ключи элементов (keyExtractor) со стабильными уникальными значениями, чтобы React понимал, какие элементы изменились, а какие нет. Если высота элементов фиксирована, нужно указать параметр getItemLayout — это позволит списку мгновенно рассчитывать позицию скролла без замеров каждого элемента. Компонент элемента списка должен быть обернут в React.memo, чтобы он не перерисовывался, если его данные не изменились. Важно избегать создания новых функций внутри renderItem (например, анонимных стрелочных функций onPress), иначе React.memo не сработает, так как функция будет считаться новой при каждом рендере. Для изображений стоит использовать специализированные библиотеки с кэшированием, так как стандартный Image может вызывать лаги при быстрой прокрутке.
В: Как выявлять и устранять лишние ре-рендеры?
О: Лишние ре-рендеры происходят, когда компонент обновляется, хотя его данные не изменились. Это нагружает процессор и снижает FPS. Основная причина — изменение состояния родителя или передача новых объектов и функций в пропсах. Для диагностики используется React DevTools (функция Highlight Updates), которая подсвечивает компоненты при обновлении. Для устранения применяется React.memo для компонентов, useMemo для тяжелых вычислений или объектов, и useCallback для функций. Также важно не хранить все состояние в одном большом объекте, а разделять его, чтобы изменение одной части не затрагивало другие компоненты. Если используется Context, нужно разделять контекст на данные и функции управления, чтобы компоненты подписывались только на нужную часть.
В: Что такое утечка памяти (Memory Leak) и как её избежать?
О: Утечка памяти возникает, когда приложение занимает память, но не освобождает её после того, как данные перестали быть нужны. Со временем это приводит к замедлению работы или аварийному закрытию приложения операционной системой. В React Native частая причина — забытые подписки на события. Например, если вы подписались на изменение состояния сети или навигации в useEffect, но не отписались при удалении компонента, эта подписка останется висеть в памяти. Чтобы избежать этого, всегда нужно возвращать функцию очистки (cleanup) в хуке useEffect, где удаляются все слушатели, таймеры и отменяются запросы. Также важно отменять сетевые запросы при размонтировании компонента, чтобы не пытаться обновить состояние уже несуществующего экрана. Для поиска утечек используются инструменты профилирования в Xcode Instruments и Android Studio Profiler.
=========================================================================
3. УПРАВЛЕНИЕ СОСТОЯНИЕМ
=========================================================================
В: Когда использовать Context API, а когда Redux/Zustand?
О: Выбор зависит от сложности данных и частоты их изменений. Context API встроен в React и удобен для данных, которые меняются редко и нужны во многих местах, например, тема оформления (темная/светлая), язык интерфейса или данные авторизованного пользователя. Однако у Context есть недостаток: при изменении значения в контексте перерисовываются все компоненты, которые его используют, даже если им нужна только часть данных. Redux Toolkit или Zustand лучше подходят для сложного, часто меняющегося состояния, например, корзины товаров, кэша данных или состояния многошаговой формы. Они позволяют компонентам подписываться только на конкретные куски состояния, что предотвращает лишние перерисовки. Кроме того, они предоставляют удобные инструменты для отладки изменений данных во времени.
В: Что такое Server State и зачем нужен React Query?
О: Server State — это данные, которые приходят с сервера (списки товаров, профили, настройки). В отличие от локального состояния интерфейса (открыто ли меню), серверные данные могут устареть, их нужно кэшировать, обновлять в фоне и обрабатывать ошибки загрузки. Пытаться хранить их в Redux вручную сложно: приходится самому писать флаги загрузки, логику кэширования и повторных запросов. React Query (TanStack Query) специализируется именно на серверном состоянии. Он автоматически кэширует данные, обновляет их в фоне при возврате на экран, предотвращает дублирование одинаковых запросов и управляет состоянием загрузки и ошибок. Использование таких инструментов позволяет убрать лишнюю логику из Redux и сосредоточиться на бизнес-задачах.
В: Как реализовать работу приложения без интернета (Offline-first)?
О: Для работы оффлайн нужно локальное хранилище данных и механизм синхронизации. Вместо AsyncStorage, который может быть медленным на больших объемах, лучше использовать базы данных вроде WatermelonDB или Realm, которые работают быстро и поддерживают реактивность. Логика работы строится так: при отсутствии сети все действия пользователя (создание записи, лайк) сохраняются в локальную базу со статусом "ожидает отправки". Специальный сервис слушает появление интернета и отправляет накопленные действия на сервер. Если сервер подтверждает успех, статус в базе меняется. Важно предусмотреть обработку конфликтов, если данные изменились и на сервере, и у клиента, а также показывать пользователю индикатор статуса синхронизации.
=========================================================================
4. НАТИВНАЯ РАЗРАБОТКА И СБОРКА
=========================================================================
В: Когда нужно писать нативный модуль?
О: React Native покрывает большинство задач, но иногда требуется нативный код (Swift/Objective-C для iOS, Kotlin/Java для Android). Это необходимо в трех случаях: во-первых, для задач, требующих высокой производительности, где JavaScript будет тормозить (обработка видео, сложные вычисления, работа с Bluetooth). Во-вторых, для доступа к функциям устройства, для которых нет готовых библиотек в React Native (специфические датчики, фоновые задачи). В-третьих, для интеграции готовых нативных SDK от сторонних сервисов (платежи, карты, аналитика). Перед написанием своего модуля всегда стоит проверить npm, так как сообщество часто уже решило эту задачу. Поддержка нативного кода усложняет разработку, так как требует знаний обеих платформ.
В: Как управлять зависимостями и конфликтами в iOS и Android?
О: В iOS зависимости управляются через CocoaPods (файл Podfile). Конфликты версий библиотек решаются фиксацией версий в Podfile и использованием скриптов post_install для настройки флагов компиляции. В Android используется Gradle (файлы build.gradle). Конфликты версий библиотек (например, разных версий Google Services) решаются через стратегию разрешения зависимостей (resolutionStrategy), где принудительно указывается единая версия для всего проекта. Частая проблема — кэш сборщиков, который приводит к странным ошибкам. Для очистки используется команда npx react-native-clean-project, которая удаляет временные файлы сборки, подов и градля, что часто решает проблемы со сборкой после обновления библиотек.
В: Как реализовать Deep Linking и открытие приложения по ссылке?
О: Deep Linking позволяет открывать приложение по ссылке (например, из письма или браузера). Для этого нужно настроить схемы URL в конфигурационных файлах платформы (Info.plist для iOS, AndroidManifest.xml для Android). Для универсальных ссылок (https), которые открывают приложение вместо браузера, требуется дополнительная настройка ассоциаций доменов на сервере и в проекте. В коде используется API linking для обработки входящих ссылок. Нужно обрабатывать два сценария: открытие ссылки при холодном старте приложения (initialUrl) и открытие, когда приложение уже запущено (подписка на события). Ссылка парсится, и приложение выполняет навигацию на нужный экран с переданными параметрами.
=========================================================================
5. ТЕСТИРОВАНИЕ И CI/CD
=========================================================================
В: Какие тесты писать и какими инструментами пользоваться?
О: Тесты делятся на три уровня. Юнит-тесты (Jest) проверяют отдельную логику: функции, утилиты, редюсеры. Они быстрые и должны покрывать бизнес-логику. Интеграционные тесты (React Native Testing Library) проверяют взаимодействие компонентов между собой, например, правильно ли форма отправляет данные. E2E тесты (Detox или Maestro) проверяют приложение целиком на реальном устройстве или эмуляторе, имитируя действия пользователя (нажатия, скролл). Они медленные и сложные в поддержке, поэтому их пишут только для критических сценариев: вход в приложение, покупка, основная навигация. Покрытие тестами должно быть разумным, не нужно стремиться к 100%, важнее покрыть рискованные места.
В: Как построить процесс автоматической сборки и публикации (CI/CD)?
О: Процесс автоматизации строится на сервисах вроде GitHub Actions, GitLab CI или Bitrise, часто в связке с инструментом Fastlane. Пайплайн состоит из этапов: проверка кода (линтер, типы), запуск тестов, сборка приложения, подпись сертификатами и публикация. Fastlane используется для автоматизации рутинных задач: управления сертификатами и профилями подписи, увеличения версии билда, загрузки скриншотов и отправки сборки в TestFlight или Google Play Console. Это позволяет выпускать релиз по нажатию кнопки или созданию тега в git, исключая ручные ошибки при сборке в Xcode или Android Studio. Секреты (ключи подписи, пароли) должны храниться в защищенном хранилище CI, а не в коде.
=========================================================================
6. БЕЗОПАСНОСТЬ И TROUBLESHOOTING
=========================================================================
В: Как диагностировать падения приложения в продакшене?
О: Для отслеживания ошибок используются сервисы вроде Sentry или Firebase Crashlytics. Они автоматически собирают отчеты о крашах на устройствах пользователей. Важно настроить символикацию — загрузку файлов расшифровки (dSYM для iOS, mapping.txt для Android), чтобы вместо непонятных адресов памяти видеть имена файлов и строки кода, где произошла ошибка. При анализе нужно отличать ошибки JavaScript (логика, типы) от нативных крашей (память, потоки). Для критических ошибок в JavaScript коде можно использовать CodePush для исправления без прохождения модерации магазина приложений, но это не работает для ошибок в нативной части.
В: Как обеспечить безопасность данных в приложении?
О: Чувствительные данные (токены доступа, пароли) нельзя хранить в обычном AsyncStorage, так как они доступны в открытом виде. Для этого нужно использовать защищенное хранилище: Keychain в iOS и Encrypted SharedPreferences/Keystore в Android (библиотека react-native-keychain). Все сетевые запросы должны идти только по HTTPS. Для защиты от перехвата трафика используется SSL Pinning — проверка сертификата сервера внутри приложения. Также рекомендуется включать обфускацию кода в релизных сборках, чтобы усложнить изучение приложения злоумышленниками, и проверять устройство на наличие Jailbreak или Root прав, ограничивая функционал на скомпрометированных устройствах.
