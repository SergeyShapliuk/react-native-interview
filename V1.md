# Справочник вопросов и ответов: React Native (Middle / Senior)

**Формат:** Markdown  
**Версия:** FINAL (Полная версия)  
**Позиция:** React Native Developer  
**Уровень:** Middle / Senior  
**Язык:** Русский

---

## Оглавление

1. [Архитектура React Native](#1-архитектура-react-native)
2. [Производительность и Оптимизация](#2-производительность-и-оптимизация)
3. [Управление Состоянием](#3-управление-состоянием)
4. [Нативная Разработка и Сборка](#4-нативная-разработка-и-сборка)
5. [Тестирование и CI/CD](#5-тестирование-и-cicd)
6. [Безопасность и Troubleshooting](#6-безопасность-и-troubleshooting)

---

## 1. Архитектура React Native

### В: Как работает React Native и что такое "Мост" (Bridge)?

**О:** 

React Native — это фреймворк для создания мобильных приложений, который позволяет писать код на JavaScript и выполнять его на мобильных устройствах. Архитектура основана на взаимодействии нескольких независимых потоков.

#### Потоки выполнения в React Native:

1. **JavaScript Thread** — выполняется весь JavaScript код, логика React, хуки, состояние компонентов, бизнес-вычисления
2. **Native Thread / UI Thread** — отрисовка интерфейса, поддержка 60 FPS, обработка касаний и жестов, нативные операции iOS/Android
3. **Native Modules Thread** — фоновые нативные задачи, сетевые запросы, файловая система, криптография, база данных

#### Как работает Мост (Bridge):

Мост — это асинхронный канал связи между JavaScript и нативными потоками.

**Процесс передачи данных:**
```
JavaScript Code → Сериализация в JSON → Bridge → Десериализация → Native Code
```

1. При изменении состояния создаётся виртуальное дерево компонентов
2. React Native вычисляет разницу между старым и новым деревом (diffing)
3. Команды для обновления UI сериализуются в JSON
4. JSON передаётся через мост в нативную очередь
5. Нативная сторона выполняет команды
6. Результат передаётся обратно тем же путём

#### Проблемы классической архитектуры:

1. **Сериализация/десериализация** — преобразование в JSON занимает время процессора
2. **Асинхронность** — нельзя получить мгновенный ответ, проблемы для анимаций и жестов
3. **Очередь сообщений** — при нагрузке сообщения накапливаются, возникают задержки и лаги
4. **Отсутствие прямой связи** — каждый вызов требует прохождения через цикл сериализации

#### Новая архитектура (Fabric и TurboModules):

* **JSI (JavaScript Interface)** — JavaScript напрямую держит ссылки на C++ объекты, вызовы становятся синхронными, нет сериализации JSON
* **Fabric** — нативная сторона знает о дереве React, приоритетная обработка UI, улучшенная координация потоков
* **TurboModules** — модули загружаются лениво, прямой доступ через JSI, улучшенная типизация

**Преимущества:** устранение узкого места моста, синхронная связь, улучшенная производительность анимаций (до 2x), быстрый старт.

---

### В: Что такое Hermes и зачем он нужен?

**О:**

Hermes — движок JavaScript с открытым исходным кодом, разработанный Facebook специально для React Native на мобильных устройствах.

#### Компиляция JavaScript:

**JavaScriptCore (JSC) — JIT компиляция:**
```
Исходный код → Запуск приложения → Компиляция при выполнении → Выполнение
```
* Компилируется в момент запуска на устройстве
* Требует времени и ресурсов при старте
* Занимает больше памяти

**Hermes — AOT компиляция:**
```
Исходный код → Сборка приложения → Байт-код (.hbc) → Запуск → Выполнение
```
* Компилируется заранее при сборке
* Устройство получает готовый байт-код
* Не тратит время на компиляцию при запуске

#### Преимущества Hermes:

1. **Время запуска** — уменьшается на 30-50%, приложение быстрее становится отзывчивым
2. **Потребление памяти** — на 20-30% меньше чем JSC, критично для Android с 2-4 GB RAM
3. **Размер приложения** — байт-код меньше исходного JS, уменьшение APK на 10-15%
4. **Производительность** — оптимизирован для паттернов React Native, лучшая работа со списками

#### Конфигурация:

**Android (build.gradle):**
```gradle
project.ext.react = [
    enableHermes: true,
    hermesFlagsRelease: ["-O", "-output-source-map"],
]
```

**iOS (Podfile):**
```ruby
use_react_native!(
  :path => config[:reactNativePath],
  :hermes_enabled => true
)
```

**Рекомендация:** Hermes должен быть включён в продакшене всегда.

---

### В: В чем разница между Debug и Release сборками?

**О:**

#### Debug сборка:

**Назначение:** Разработка, тестирование, отладка

**Характеристики:**
* Metro Bundler запускает сервер разработки
* Код бандлируется "на лету" при изменениях
* Поддерживается Hot Reload и Fast Refresh
* Движок в режиме отладки (медленнее)
* Отключены оптимизации компилятора
* Сохраняются имена переменных и функций
* Подключение к Chrome DevTools / Flipper
* Разрешены HTTP соединения
* Доступен debug server на порту 8081
* Включены подробные логи
* Значительно медленнее Release
* Больший размер бандла

#### Release сборка:

**Назначение:** Публикация в магазины, пользователи

**Характеристики:**
* Минификация JavaScript кода
* Удаление whitespace и комментариев
* Сокращение имён переменных
* Tree shaking (удаление неиспользуемого кода)
* **Android:** ProGuard/R8 обфускация
* **iOS:** LLVM оптимизации, strip debug symbols
* Hermes байт-код по умолчанию
* Только HTTPS соединения
* App Transport Security (iOS)
* Network Security Config (Android)
* Отключён debug server
* Максимальная производительность

#### Почему баги только в Release:

1. **Timing issues** — код выполняется быстрее, race conditions проявляются иначе
2. **Обфускация** — проксирование ломается из-за изменения имён классов
3. **Безопасность** — строгая политика блокирует HTTP запросы
4. **Оптимизации** — некоторые оптимизации меняют поведение кода

---

## 2. Производительность и Оптимизация

### В: Как оптимизировать производительность FlatList?

**О:**

FlatList — основной компонент для списков, требует настройки для больших данных.

#### Основные правила:

**1. keyExtractor — обязательные стабильные ключи**
```javascript
<FlatList
  data={data}
  keyExtractor={(item) => item.id.toString()}
  renderItem={renderItem}
/>
```
Использование индекса массива ведёт к перерисовке всех элементов при изменениях.

**2. getItemLayout — для фиксированной высоты**
```javascript
getItemLayout={(data, index) => (
  {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}
)}
```
Отключает измерение высоты каждого элемента, мгновенный скролл.

**3. React.memo для элементов**
```javascript
const ListItem = React.memo(({item, onPress}) => (
  <TouchableOpacity onPress={onPress}>
    <Text>{item.name}</Text>
  </TouchableOpacity>
));
```
Предотвращает перерисовку при неизменных props.

**4. useCallback для функций**
```javascript
const renderItem = useCallback(({item}) => (
  <ListItem item={item} onPress={handlePress} />
), [handlePress]);
```
Иначе React.memo не сработает из-за новой функции каждый рендер.

**5. removeClippedSubviews (Android)**
```javascript
removeClippedSubviews={true}
```
Удаляет элементы за пределами экрана из памяти.

**6. windowSize и maxToRenderPerBatch**
```javascript
windowSize={5}
maxToRenderPerBatch={10}
updateCellsBatchingPeriod={100}
```
Контролируют количество рендеримых элементов.

**7. Изображения**
```javascript
import FastImage from 'react-native-fast-image';
```
Стандартный Image кэширует плохо, FastImage решает проблему.

---

### В: Как выявлять и устранять лишние ре-рендеры?

**О:**

Лишние ре-рендеры нагружают процессор и снижают FPS.

#### Причины:

1. Изменение состояния родителя
2. Создание новых объектов/функций в теле компонента
3. Неправильное использование Context
4. Отсутствие React.memo для дочерних компонентов

#### Диагностика:

**React DevTools — Highlight Updates**
```
Включить в настройках DevTools
Компоненты подсвечиваются при обновлении
Зелёный = новый, жёлтый = обновлённый
```

**Библиотека why-did-you-render**
```javascript
import whyDidYouRender from '@welldone-software/why-did-you-render';
whyDidYouRender(React);
```
Показывает в консоли причину каждого ре-рендера.

#### Устранение:

**1. React.memo**
```javascript
const MyComponent = React.memo(({data, onPress}) => {
  return <View>{data}</View>;
});
```

**2. useMemo для вычислений**
```javascript
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
```

**3. useCallback для функций**
```javascript
const handleClick = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

**4. Разделение состояния**
```javascript
// Вместо одного объекта
const [state, setState] = useState({a: 1, b: 2});

// Использовать несколько useState
const [a, setA] = useState(1);
const [b, setB] = useState(2);
```

**5. Разделение Context**
```javascript
const DataContext = createContext();
const ActionsContext = createContext();
```
Компоненты подписываются только на нужную часть.

---

### В: Что такое утечка памяти и как её избежать?

**О:**

Утечка памяти возникает, когда объект не удаляется сборщиком мусора, хотя больше не используется.

#### Частые причины:

**1. Подписки на события**
```javascript
// ❌ Неправильно
useEffect(() => {
  const subscription = eventListener.addListener('event', handler);
}, []);

// ✅ Правильно
useEffect(() => {
  const subscription = eventListener.addListener('event', handler);
  return () => subscription.remove();
}, []);
```

**2. Таймеры**
```javascript
useEffect(() => {
  const timer = setInterval(() => {}, 1000);
  return () => clearInterval(timer);
}, []);
```

**3. Сетевые запросы**
```javascript
useEffect(() => {
  const controller = new AbortController();
  fetchData({signal: controller.signal});
  return () => controller.abort();
}, []);
```

**4. Навигация**
```javascript
useEffect(() => {
  const unsubscribe = navigation.addListener('focus', handler);
  return unsubscribe;
}, [navigation]);
```

**5. Изображения**
* Загрузка огромных изображений без ресайза
* Решение: react-native-fast-image, ресайз на сервере

#### Инструменты диагностики:

* **Xcode Instruments → Allocations** (iOS)
* **Android Studio Profiler** (Android)
* **Flipper → Memory Inspector**
* **Chrome DevTools → Memory tab**

#### Признаки утечки:

* График памяти растёт при навигации вперёд-назад
* Память не освобождается после ухода с экрана
* Приложение закрывается системой (OOMKilled)

---

## 3. Управление Состоянием

### В: Когда использовать Context API, а когда Redux/Zustand?

**О:**

#### Context API:

**Когда использовать:**
* Данные меняются редко
* Нужны во многих местах
* Тема (тёмная/светлая)
* Язык (локаль)
* Данные авторизованного пользователя

**Преимущества:**
* Встроен в React
* Не требует дополнительных библиотек
* Простая настройка

**Недостатки:**
* Любое изменение вызывает ре-рендер ВСЕХ потребителей
* Нет встроенных DevTools
* Сложно отлаживать потоки данных
* Проблемы с производительностью на больших экранах

#### Redux Toolkit / Zustand:

**Когда использовать:**
* Сложное, часто меняющееся состояние
* Корзина товаров
* Кэш данных API
* Многошаговые формы
* Состояние используется в несвязанных компонентах

**Преимущества:**
* Селекторы для подписки на конкретные куски стейта
* Изменение одного поля не затрагивает другие компоненты
* DevTools для отслеживания истории
* Middleware (логирование, аналитика, thunk, saga)
* Предсказуемое состояние

**Недостатки:**
* Boilerplate (в Redux)
* Лишняя сложность для простых задач
* Требует изучения

#### Рекомендация:

Избегать глобального стейта там, где можно использовать локальный. Для данных API использовать React Query. Redux оставлять для действительно глобального UI-состояния.

---

### В: Что такое Server State и зачем нужен React Query?

**О:**

#### Client State vs Server State:

| Client State | Server State |
|--------------|--------------|
| UI-флаги (модал открыт) | Данные с сервера |
| Значение инпута | Список товаров |
| Тема оформления | Профиль пользователя |
| Хранится в useState/Redux | Хранится в кэше |

#### Проблемы хранения Server State в Redux:

1. Нужно вручную писать флаги isLoading, isError
2. Нужно вручную реализовывать кэширование
3. Нужно вручную делать ре-фетч при фокусе окна
4. Race conditions при параллельных запросах
5. Сложная инвалидация кэша

#### React Query решает:

**1. Автоматическое кэширование**
```javascript
const {data, isLoading} = useQuery(['users'], fetchUsers);
```
Кэш по ключам запроса, stale-while-revalidate стратегия.

**2. Фоновое обновление**
```javascript
useQuery(['users'], fetchUsers, {
  staleTime: 5 * 60 * 1000, // 5 минут
  refetchOnWindowFocus: true,
});
```

**3. Дедупликация запросов**
Если два компонента запросили одно и то же — запрос будет один.

**4. Мутации**
```javascript
const mutation = useMutation({
  mutationFn: createUser,
  onSuccess: () => {
    queryClient.invalidateQueries(['users']);
  },
});
```

**5. Пагинация и бесконечный скролл**
```javascript
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage) => lastPage.nextCursor,
});
```

#### Рекомендация:

Не хранить данные API в Redux. Использовать React Query для server state, Redux/Zustand для client state.

---

### В: Как реализовать Offline-first архитектуру?

**О:**

Приложение должно работать без интернета с последующей синхронизацией.

#### Компоненты:

**1. Локальная база данных**
* **WatermelonDB** — предпочтительно для RN (ленивая загрузка, реактивность)
* **Realm** — быстрая, но требует нативной настройки
* **SQLite** — через react-native-sqlite-storage

**2. Синхронизация**
```javascript
// Pull — загрузка изменений с сервера
const pullChanges = async () => {
  const changes = await api.getChanges(lastSyncTimestamp);
  await database.write(() => {
    changes.forEach(change => applyChange(change));
  });
};

// Push — отправка локальных изменений
const pushChanges = async () => {
  const pending = await database.getPendingChanges();
  await api.sync(pending);
  await database.markAsSynced(pending);
};
```

**3. Очередь действий**
```javascript
// Действия сохраняются со статусом "pending"
await database.write(() => {
  const record = table.create(record => {
    record.name = 'New Item';
    record._status = 'pending';
  });
});

// При появлении сети отправляются
NetInfo.addEventListener(state => {
  if (state.isConnected) {
    syncPendingActions();
  }
});
```

**4. Обработка конфликтов**
* Last-write-wins (последняя запись побеждает)
* Серверная логика разрешения
* Ручное вмешательство пользователя

**5. UI индикация**
* Статус соединения
* Статус синхронизации
* Индикатор "оффлайн режим"

**6. Retry Logic**
```javascript
const retryWithBackoff = async (fn, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (e) {
      await delay(Math.pow(2, i) * 1000); // Экспоненциальная задержка
    }
  }
};
```

---

## 4. Нативная Разработка и Сборка

### В: Когда нужно писать нативный модуль?

**О:**

#### Причины для нативного кода:

**1. Производительность**
* Тяжёлые вычисления в JS блокируют UI поток
* Обработка видео/аудио в реальном времени
* Работа с Bluetooth/NFC
* Криптографические операции

**2. Доступ к API**
* Специфические датчики устройства
* Background Tasks
* Push Notifications (глубокая настройка)
* Contact Book, Calendar
* Функции без обёртки в React Native

**3. Готовые SDK**
* Платёжные системы (Stripe, PayPal)
* Карты (Google Maps, Mapbox)
* Аналитика (Firebase, AppsFlyer)
* Только нативные библиотеки (.aar, .framework)

**4. Исправление багов**
* Баг в самом React Native
* Баг в библиотеке
* Патч ещё не вышел

#### Пример нативного модуля:

**iOS (Swift):**
```swift
@objc(MyNativeModule)
class MyNativeModule: NSObject {
  @objc func multiply(_ a: Double, b: Double, resolver: RCTPromiseResolveBlock, rejecter: RCTPromiseRejectBlock) {
    resolver(a * b)
  }
}
```

**Android (Kotlin):**
```kotlin
class MyNativeModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
  @ReactMethod
  fun multiply(a: Double, b: Double, promise: Promise) {
    promise.resolve(a * b)
  }
}
```

**JavaScript:**
```javascript
import {NativeModules} from 'react-native';
const {MyNativeModule} = NativeModules;
const result = await MyNativeModule.multiply(3, 4);
```

#### Рекомендация:

Перед написанием своего модуля проверить npm и GitHub. Сообщество огромно, задача скорее всего уже решена. Поддержка нативного кода удорожает разработку.

---

### В: Как управлять зависимостями и конфликтами?

**О:**

#### iOS (CocoaPods):

**Файл:** `ios/Podfile`

**Базовая настройка:**
```ruby
platform :ios, '13.0'

target 'MyApp' do
  pod 'React-Core', :path => '../node_modules/react-native'
  pod 'RNVectorIcons', :path => '../node_modules/react-native-vector-icons'
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '13.0'
    end
  end
end
```

**Команды:**
```bash
cd ios
pod install
pod update
pod deintegrate && pod install # Полная переустановка
```

**Решение конфликтов:**
```ruby
# Фиксация версий
pod 'AFNetworking', '~> 4.0'

# Принудительная версия для всех
$FirebaseVersion = '10.0.0'
pod 'FirebaseAnalytics', $FirebaseVersion
```

#### Android (Gradle):

**Файл:** `android/app/build.gradle`

**Базовая настройка:**
```gradle
android {
  compileSdkVersion 33
  defaultConfig {
    applicationId "com.myapp"
    minSdkVersion 21
    targetSdkVersion 33
  }
}

dependencies {
  implementation 'com.facebook.react:react-native:+'
  implementation 'com.google.android.material:material:1.9.0'
}
```

**Решение конфликтов:**
```gradle
configurations.all {
  resolutionStrategy {
    force 'com.google.android.gms:play-services-base:18.2.0'
    force 'androidx.core:core-ktx:1.10.0'
  }
}
```

**Команды:**
```bash
cd android
./gradlew clean
./gradlew build
```

#### Очистка проекта:

```bash
npx react-native-clean-project
```
Удаляет кэши Metro, Gradle, CocoaPods, build папки. Решает 90% магических ошибок сборки.

---

### В: Как реализовать Deep Linking?

**О:**

Deep Linking позволяет открывать приложение по ссылке из браузера, email, других приложений.

#### Типы ссылок:

1. **Custom Scheme:** `myapp://screen/id`
2. **Universal Links (iOS):** `https://myapp.com/screen`
3. **App Links (Android):** `https://myapp.com/screen`

#### Настройка iOS:

**Info.plist:**
```xml
<key>CFBundleURLTypes</key>
<array>
  <dict>
    <key>CFBundleURLSchemes</key>
    <array>
      <string>myapp</string>
    </array>
  </dict>
</array>
```

**Universal Links:**
* Файл `apple-app-site-association` на сервере
* Настройка в Xcode (Signing & Capabilities → Associated Domains)
* Домен должен быть HTTPS

#### Настройка Android:

**AndroidManifest.xml:**
```xml
<intent-filter>
  <action android:name="android.intent.action.VIEW" />
  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />
  <data android:scheme="myapp" />
</intent-filter>
```

**App Links:**
* Файл `assetlinks.json` на сервере
* Настройка в AndroidManifest (autoVerify="true")

#### Обработка в коде:

```javascript
import Linking from 'react-native/Libraries/Linking/Linking';

// При холодном старте
const initialUrl = await Linking.getInitialURL();
if (initialUrl) {
  handleDeepLink(initialUrl);
}

// Когда приложение уже открыто
useEffect(() => {
  const subscription = Linking.addEventListener('url', ({url}) => {
    handleDeepLink(url);
  });
  return () => subscription.remove();
}, []);

// Парсинг URL
const handleDeepLink = (url) => {
  const {pathname, queryParams} = parseUrl(url);
  navigation.navigate(pathname, queryParams);
};
```

#### React Navigation интеграция:

```javascript
import {Linking} from 'react-native';
import {createNavigationContainerRef} from '@react-navigation/native';

const linking = {
  prefixes: ['https://myapp.com', 'myapp://'],
  config: {
    screens: {
      Home: '',
      Profile: 'user/:id',
      Settings: 'settings',
    },
  },
};

<NavigationContainer linking={linking}>
  {/* ... */}
</NavigationContainer>
```

---

## 5. Тестирование и CI/CD

### В: Какие тесты писать и какими инструментами?

**О:**

#### Пирамида тестирования:

**1. Unit Tests (Юнит-тесты)**
* **Что тестировать:** утилиты, хелперы, редюсеры, кастомные хуки
* **Инструменты:** Jest, React Native Testing Library
* **Скорость:** Быстрые (секунды)
* **Покрытие:** 80%+ бизнес-логики

```javascript
// __tests__/utils.test.js
import {formatPrice} from '../utils';

test('formats price correctly', () => {
  expect(formatPrice(1000)).toBe('1 000 ₽');
});
```

**2. Integration Tests (Интеграционные)**
* **Что тестировать:** взаимодействие компонентов, навигацию, Redux/Context
* **Инструменты:** React Native Testing Library
* **Скорость:** Средние (минуты)

```javascript
// __tests__/LoginForm.test.js
test('submits form with valid data', async () => {
  render(<LoginForm />);
  fireEvent.changeText(getByTestId('email'), 'test@test.com');
  fireEvent.press(getByTestId('submit'));
  expect(onSubmit).toHaveBeenCalledWith({email: 'test@test.com'});
});
```

**3. E2E Tests (End-to-End)**
* **Что тестировать:** критические пользовательские сценарии
* **Инструменты:** Detox (лучше для RN), Maestro (новый, проще), Appium
* **Скорость:** Медленные (десятки минут)
* **Покрытие:** Только Happy Path

```javascript
// e2e/login.spec.js
describe('Login', () => {
  it('should login successfully', async () => {
    await element(by.id('email')).typeText('test@test.com');
    await element(by.id('password')).typeText('password123');
    await element(by.id('login')).tap();
    await expect(element(by.id('home'))).toBeVisible();
  });
});
```

#### Рекомендации:

* Не стремиться к 100% покрытию
* E2E тесты дорогие в поддержке — писать только для критических путей
* Запускать в CI на каждый PR
* Mock внешних зависимостей (API, навигация)

---

### В: Как построить процесс CI/CD?

**О:**

#### Инструменты:

* **CI:** GitHub Actions, GitLab CI, Bitrise, CircleCI
* **CD:** Fastlane, EAS Build (Expo)
* **Distribution:** TestFlight, Firebase App Distribution, App Center

#### Пайплайн:

```yaml
# .github/workflows/ci.yml
name: CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm test
      
  build-ios:
    needs: test
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: cd ios && pod install
      - run: fastlane ios beta
      
  build-android:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: cd android && ./gradlew assembleRelease
      - run: fastlane android beta
```

#### Fastlane конфигурация:

**Fastfile:**
```ruby
lane :ios_beta do
  increment_build_number
  build_app(
    scheme: "MyApp",
    export_method: "app-store"
  )
  upload_to_testflight
end

lane :android_beta do
  increment_version_code
  gradle(task: "assemble", build_type: "Release")
  upload_to_play_store(track: "internal")
end
```

#### Управление секретами:

* **Никогда не коммитить** секреты в Git
* Использовать CI variables / secrets
* Fastlane Match для сертификатов iOS
* Keystore в защищённом хранилище (AWS Secrets Manager, Vault)

#### Feature Flags:

```javascript
import RemoteConfig from '@react-native-firebase/remote-config';

const defaults = {
  new_feature_enabled: false,
};

RemoteConfig.setDefaults(defaults);
await RemoteConfig.fetchAndActivate();

if (RemoteConfig.getValue('new_feature_enabled').asBoolean()) {
  // Показать новую фичу
}
```

---

## 6. Безопасность и Troubleshooting

### В: Как диагностировать падения в продакшене?

**О:**

#### Инструменты мониторинга:

**1. Sentry**
* JavaScript и нативные краши
* Source maps для расшифровки
* Breadcrumbs (путь пользователя перед крашем)
* Release tracking

**2. Firebase Crashlytics**
* Нативные краши
* Custom keys для контекста
* User identifiers для отслеживания

#### Настройка Source Maps:

**iOS (dSYM):**
```bash
# В Xcode Build Phases
export SOURCEMAP_FILE="../.react-native/index.android.bundle.map"
../node_modules/react-native/scripts/generate-source-map.sh
```

**Android (mapping.txt):**
```gradle
android {
  buildTypes {
    release {
      minifyEnabled true
      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
  }
}
```

**Загрузка в Sentry:**
```bash
sentry-cli react-native xcode \
  --include-sources \
  ../node_modules/react-native/scripts/react-native-xcode.sh

sentry-cli upload-proguard \
  --android-manifest app/build/outputs/mapping/release/mapping.txt
```

#### Анализ крашей:

**JavaScript краши:**
* undefined is not a function
* Cannot read property of null
* Type errors
* **Решение:** TypeScript,PropTypes, валидация данных

**Нативные краши:**
* EXC_BAD_ACCESS (iOS) — доступ к освобождённой памяти
* NullPointerException (Android) — null reference
* **Решение:** Проверка null, корректная работа с потоками

#### CodePush для хотфиксов:

```javascript
import codePush from 'react-native-code-push';

const codePushOptions = {
  checkFrequency: codePush.CheckFrequency.ON_APP_START,
  installMode: codePush.InstallMode.IMMEDIATE,
};

export default codePush(codePushOptions)(App);
```

**Важно:** CodePush работает только для JavaScript кода, не для нативных изменений.

---

### В: Как обеспечить безопасность данных?

**О:**

#### Хранение чувствительных данных:

**❌ Неправильно:**
```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';
await AsyncStorage.setItem('token', token); // Доступно с root правами!
```

**✅ Правильно:**
```javascript
import * as Keychain from 'react-native-keychain';

// Сохранение
await Keychain.setGenericPassword('username', token, {
  accessControl: Keychain.ACCESS_CONTROL.BIOMETRY_ANY,
  accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
});

// Чтение
const credentials = await Keychain.getGenericPassword();

// Удаление
await Keychain.resetGenericPassword();
```

#### Network Security:

**1. Только HTTPS**
```javascript
// iOS: Info.plist
<key>NSAppTransportSecurity</key>
<dict>
  <key>NSAllowsArbitraryLoads</key>
  <false/>
</dict>

// Android: network_security_config.xml
<network-security-config>
  <base-config cleartextTrafficPermitted="false"/>
</network-security-config>
```

**2. SSL Pinning**
```javascript
import SSLPin from 'react-native-ssl-pinning';

const response = await fetch('https://api.example.com/data', {
  sslPinning: {
    certs: ['mycert'],
  },
});
```
Проверка сертификата сервера внутри приложения, защита от MITM.

#### Обфускация:

**Android (ProGuard):**
```gradle
buildTypes {
  release {
    minifyEnabled true
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
}
```

**proguard-rules.pro:**
```proguard
-keep class com.myapp.** { *; }
-keepclassmembers class * {
  @react.* <methods>;
}
```

#### Jailbreak/Root Detection:

```javascript
import DeviceInfo from 'react-native-device-info';

const isJailbroken = await DeviceInfo.isJailbroken();
const isEmulator = await DeviceInfo.isEmulator();

if (isJailbroken || isEmulator) {
  // Ограничить функционал или показать предупреждение
}
```

#### Биометрия:

```javascript
import TouchID from 'react-native-touch-id';

const optionalConfigObject = {
  title: 'Аутентификация',
  fallbackLabel: 'Ввести пароль',
  unifiedTitle: 'Авторизоваться',
};

TouchID.authenticate('Подтвердите личность', optionalConfigObject)
  .then(success => {
    // Доступ разрешён
  })
  .catch(error => {
    // Ошибка или отмена
  });
```

---

## Заключение

Этот справочник покрывает основные темы для собеседования на позицию React Native разработчика уровня Middle/Senior.

### Ключевые рекомендации:

1. **Понимать архитектуру** — не просто использовать, а знать как работает под капотом
2. **Оптимизировать осознанно** — профилировать перед оптимизацией, использовать правильные инструменты
3. **Разделять состояние** — client state vs server state, локальное vs глобальное
4. **Автоматизировать** — CI/CD, тесты, линтинг, типизация
5. **Безопасность с начала** — не добавлять в конце, а закладывать в архитектуру
6. **Мониторинг** — Sentry, Crashlytics, аналитика производительности
7. **Документировать** — код, API, процессы для команды

### Для подготовки к собеседованию:

* Пройтись по каждому вопросу и попробовать объяснить своими словами
* Подготовить примеры из своего опыта
* Изучить последнюю версию React Native и новые фичи
* Практиковаться в решении задач на производительность
* Знать различия iOS и Android платформ

---

**Конец справочника**
