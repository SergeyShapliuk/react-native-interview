# Справочник вопросов и ответов для собеседования: React Native

**Версия:** 1.0  
**Позиция:** React Native Developer  
**Уровень:** Middle / Senior  
**Язык:** Русский

---

## Оглавление

1. [Производительность React Native](#1-производительность-react-native)
2. [Архитектура и Мост (Bridge)](#2-архитектура-и-мост-bridge)
3. [Новая Архитектура](#3-новая-архитектура)
4. [React Native CLI vs Expo](#4-react-native-cli-vs-expo)
5. [Стилизация компонентов](#5-стилизация-компонентов)
6. [Платформо-специфичный код](#6-платформо-специфичный-код)
7. [Списки: FlatList vs ScrollView](#7-списки-flatlist-vs-scrollview)
8. [Нативные модули](#8-нативные-модули)
9. [Преимущества React Native](#9-преимущества-react-native)
10. [Ограничения React Native](#10-ограничения-react-native)

---

## 1. Производительность React Native

### В: Как React Native обеспечивает производительность на уровне нативных приложений?

**О:**

React Native обеспечивает производительность на уровне нативных приложений благодаря нескольким ключевым функциям:

#### Прямой нативный рендеринг

React Native напрямую сопоставляется с нативными компонентами пользовательского интерфейса, что позволяет приложению отображать элементы UI с помощью нативных API платформы. В результате пользовательский интерфейс становится неотличимым от интерфейса, созданного с помощью нативного кода.

#### Собственные потоки

В React Native обычно используются **3 потока**:

| Поток | Описание |
|-------|----------|
| **Поток пользовательского интерфейса (UI Thread)** | Основной поток, отвечающий за инициализацию приложения, рендеринг UI, обработку сенсорных событий и вызов потока JavaScript. Самое большое преимущество — может работать параллельно с потоком JavaScript, обеспечивая плавный UI даже при выполнении ресурсоёмких вычислений. |
| **Поток JavaScript** | Выполняет код JavaScript, включая логику приложения React Native. Взаимодействует с потоком UI, обновляя UI в зависимости от действий пользователя и изменений в состоянии приложения. |
| **Теневой поток (Shadow Thread)** | Отвечает за компоновку и измерение UI. До его появления за компоновку и измерение отвечал поток UI. Благодаря разделению обязанностей React Native стал работать намного стабильнее, особенно при работе со сложными макетами. |

#### Оптимизированные обновления пользовательского интерфейса

Благодаря использованию React в качестве основы, **процесс согласования** (reconciliation) позволяет интеллектуально обновлять только необходимые части пользовательского интерфейса, сокращая ненужный рендеринг и повышая производительность.

---

## 2. Архитектура и Мост (Bridge)

### В: Какова роль моста в React Native?

**О:**

**Bridge (Мост)** в React Native — это важнейший компонент, обеспечивающий взаимодействие между кодом JavaScript и нативными модулями. Он выступает в качестве двустороннего канала связи, позволяя JavaScript вызывать нативные API и наоборот.

#### Как работает мост:

```
JavaScript Code → Сообщение → Bridge → Нативный код → Результат → Bridge → JavaScript
```

1. Когда JavaScript-коду требуется доступ к нативному модулю, он отправляет сообщение в мост
2. Мост перенаправляет запрос в соответствующий нативный код
3. Нативный код обрабатывает запрос и отправляет результат обратно через мост на сторону JavaScript
4. Обмен данными через мост осуществляется **асинхронно и пакетно**

#### Технические детали:

* Данные **сериализуются и десериализуются** в формат, похожий на JSON, при прохождении через мост
* Обе стороны могут эффективно взаимодействовать, несмотря на то, что написаны на разных языках (JavaScript и нативный код)
* **Мост в основном работает в основном потоке/потоке пользовательского интерфейса и не имеет собственного потока**

#### Проблемы моста:

* Может вызывать **задержки** из-за дополнительных затрат на сериализацию и десериализацию
* Особенно заметно при работе с:
  * Большими объёмами данных
  * Частыми обменами
  * Сложными объектами

---

## 3. Новая Архитектура

### В: Что представляет собой новая архитектура React Native?

**О:**

Новая архитектура React Native — это полная переработка основных систем, таких как рендеринг, взаимодействие между нативным кодом и кодом на JavaScript и т.д. Она направлена на повышение производительности, гибкости и удобства для разработчиков.

#### Ключевые изменения:

| Аспект | Старая архитектура | Новая архитектура |
|--------|-------------------|-------------------|
| **Связь JS-Native** | Через Bridge (асинхронно) | Через JSI (синхронно) |
| **Сериализация** | Требуется (JSON) | Не требуется |
| **Вызовы** | Асинхронные | Синхронные и асинхронные |
| **Производительность** | Ограничена мостом | Значительно выше |

#### Самое большое изменение — отказ от Bridge

Раньше Bridge был узким местом, что приводило к проблемам с производительностью и задержкам. Новая архитектура значительно улучшает JavaScript-абстракции и обеспечивает взаимодействие с нативным кодом с помощью **JavaScript Interface (JSI)**, что позволяет напрямую обращаться к нативным API без сериализации и десериализации.

**Теперь можно синхронно вызывать нативный код из JavaScript.**

#### Практический пример проблемы Bridge:

Одна из самых распространённых проблем, которую разработчики могут воспроизвести из-за печально известной задержки Bridge — это **быстрый ввод в поле с ограниченным доступом**.

* Bridge не справляется с быстрыми изменениями
* Возникают ошибки и курсор отстаёт от того, что вводит пользователь
* Проблема в том, что после каждого нажатия клавиши данные должны были передаваться через Bridge на нативную сторону, которая запрашивала обновление значения

---

## 4. React Native CLI vs Expo

### В: В чем разница между использованием React Native CLI и Expo?

**О:**

Для создания приложения React Native у вас есть два варианта:

1. **React Native CLI** (интерфейс командной строки) — создать проект с нуля. Даёт полный контроль и гибкость при настройке проекта и интеграции нативного кода.
2. **Expo** — фреймворк, созданный на основе React Native, который упрощает создание и развертывание приложений, но ограничивает доступ к нативным модулям и API.

#### Сравнительная таблица:

| Особенность | React Native CLI | Expo |
|-------------|------------------|------|
| **Рабочий процесс разработки** | Более гибкий и настраиваемый, но требует дополнительной настройки | Оптимизировано и управляется, что упрощает разработку |
| **Нативный доступ** | Полный доступ к нативному коду и модулям | Ограниченный доступ к нативным модулям — для полного контроля требуется prebuild |
| **Процесс сборки** | Разработчики управляют процессом сборки | Expo управляет процессом сборки (через EAS — Expo Application Services) |
| **Кривая обучения** | Сложнее для новичков | Проще для начинающих |
| **Идеальные варианты использования** | Сложные приложения, требующие обширной настройки | Быстрое прототипирование и небольшие проекты для ускоренной разработки |

> **ПРИМЕЧАНИЕ:** Несмотря на то, что для использования Expo в сложных приложениях требуются дополнительные обходные пути, с помощью Expo можно разрабатывать сложные приложения. Можно комбинировать React Native с нативным кодом на Swift (App Clips, Widgets).

---

## 5. Стилилизация компонентов

### В: Как стилизовать компонент в React Native?

**О:**

Как и в React, в React Native есть множество способов стилизовать компоненты:

#### 1. Встроенные стили

Самый быстрый (и грязный) способ стилизовать компонент. Вы можете передать объект стиля непосредственно в свойство `style` компонента.

```javascript
<View style={{ backgroundColor: 'red', padding: 10 }}>
  <Text>Привет</Text>
</View>
```

#### 2. Модули CSS-in-JS (Styled Components)

Используя тот же подход CSS-in-JS, что и React, вы можете применять такие библиотеки, как **Styled Components**, для стилизации своих компонентов. Это позволяет писать CSS прямо в файлах JavaScript.

```javascript
import styled from 'styled-components/native';

const Container = styled.View`
  background-color: red;
  padding: 10px;
`;

<Container>
  <Text>Привет</Text>
</Container>
```

#### 3. StyleSheet API (Рекомендуемый способ)

Это рекомендуемый способ оформления компонентов в React Native. StyleSheet API позволяет создать объект таблицы стилей, который можно использовать в нескольких компонентах.

```javascript
import { StyleSheet, View, Text } from 'react-native';

const styles = StyleSheet.create({
  container: {
    backgroundColor: 'red',
    padding: 10,
  },
  text: {
    color: 'white',
  },
});

<View style={styles.container}>
  <Text style={styles.text}>Привет</Text>
</View>
```

> **Совет:** Храните стили в отдельном файле и импортируйте их в файл с компонентом. Так код будет чистым и удобным для поддержки.

> **ПРИМЕЧАНИЕ:** React Native использует **Yoga** для верстки, которая имеет доступ к меньшему набору свойств CSS.

---

## 6. Платформо-специфичный код

### В: Как работать с кодом, специфичным для конкретной платформы, в React Native?

**О:**

React Native предоставляет несколько способов работы с кодом, специфичным для конкретной платформы:

#### 1. Platform.OS

Platform.OS API позволяет проверить текущую платформу (iOS, Android или веб) и обычно используется для условного отображения компонентов или стилей в зависимости от платформы.

```javascript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    paddingTop: Platform.OS === 'ios' ? 50 : 20,
  },
});
```

#### 2. Platform.select

Если вы планируете поддерживать несколько платформ, вам может быть проще использовать метод Platform.select — создайте один объект, содержащий условный код для каждой платформы, и React Native автоматически выберет нужный вариант в зависимости от текущей платформы.

```javascript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      ios: {
        paddingTop: 50,
      },
      android: {
        paddingTop: 20,
      },
      web: {
        paddingTop: 0,
      },
    }),
  },
});
```

#### 3. Расширения файлов, зависящие от платформы

React Native позволяет создавать файлы для конкретных платформ с помощью расширений. Например, если у вас есть компонент, который должен вести себя по-разному на iOS и Android, вы можете создать два отдельных файла с одинаковыми названиями, но разными расширениями.

```
Component.ios.js
Component.android.js
Component.js (fallback)
```

Когда вы импортируете `Component`, React Native автоматически выберет правильный файл в зависимости от текущей платформы.

**Другие расширения:**
* `.ios.js`
* `.android.js`
* `.native.js`
* `.jsx` & `.tsx` эквиваленты

> Этот подход наиболее удобен для работы с кодовой базой, предназначенной как для нативных, так и для веб-приложений.

---

## 7. Списки: FlatList vs ScrollView

### В: В чем разница между FlatList и ScrollView и когда лучше использовать один из них, а не другой?

**О:**

И **FlatList** и **ScrollView** используются для отображения списков элементов в React Native, но у них разные сценарии использования и характеристики производительности.

#### ScrollView

* Простой компонент, который отображает свои дочерние элементы в прокручиваемом виде
* **Отображает все свои дочерние элементы сразу**
* Лучше всего подходит для **небольших списков элементов**
* Может привести к проблемам с производительностью при работе с большими списками

```javascript
<ScrollView>
  <View><Text>Item 1</Text></View>
  <View><Text>Item 2</Text></View>
  {/* Все элементы рендерятся сразу */}
</ScrollView>
```

#### FlatList

* Более продвинутый компонент, **оптимизированный для отображения больших списков элементов**
* Отображает на экране только определенное количество элементов
* Загружает новые по мере прокрутки списка пользователем
* Повышает производительность и снижает потребление памяти

```javascript
<FlatList
  data={data}
  renderItem={({item}) => <Text>{item.name}</Text>}
  keyExtractor={(item) => item.id}
/>
```

#### FlashList (Альтернатива от Shopify)

В большинстве реальных случаев даже FlatList недостаточно эффективен. Поэтому ребята из **Shopify** создали новый компонент под названием **FlashList**, который практически полностью заменяет FlatList и работает намного быстрее.

**FlashList использует технику "переработка ячеек" (cell recycling):**
* Отображает только видимую часть списка
* Повторно использует представления по мере прокрутки пользователем
* Сокращает использование памяти и повышает производительность

```javascript
import {FlashList} from '@shopify/flash-list';

<FlashList
  data={data}
  renderItem={({item}) => <Text>{item.name}</Text>}
  estimatedItemSize={50}
  estimatedListSize={500}
/>
```

---

## 8. Нативные модули

### В: Для чего нужны нативные модули в React Native?

**О:**

React Native позволяет разработчикам использовать API-интерфейсы для конкретных платформ, библиотеки и нативные функции, написанные на языке платформы (например, Java / Swift / Objective-C), для добавления пользовательских функций в свои приложения, если существующие модули React Native не поддерживают их «из коробки».

#### Как работает:

* Система **NativeModule** предоставляет экземпляры нативных классов JavaScript в виде объектов JS
* Позволяет выполнять произвольный нативный код из JS
* Взаимодействие между JavaScript и нативным кодом осуществляется через **мост**

#### Новая архитектура — Turbo Native Module:

В новой архитектуре представлен **Turbo Native Module**, который похож на React Native с его нативными модулями, но использует **JSI** для прямых синхронных вызовов между JavaScript и нативным кодом, что значительно повышает производительность.

#### Когда нужны нативные модули:

| Сценарий | Пример |
|----------|--------|
| **Специфичные API платформы** | Camera, Bluetooth, NFC |
| **Сложные вычисления** | Обработка видео, криптография |
| **Сторонние SDK** | Платежи, карты, аналитика |
| **Кастомные функции** | App Clips, Widgets, Background Tasks |

---

## 9. Преимущества React Native

### В: В чем преимущества React Native?

**О:**

React Native — один из самых популярных кроссплатформенных фреймворков. Использование React Native дает множество преимуществ:

#### 1. Кроссплатформенная разработка

React Native идеально подходит для реализации принципа **«напиши один раз, запускай везде»**. Он позволяет разработчикам писать код, который можно использовать на платформах iOS и Android, что сокращает время и трудозатраты на разработку.

#### 2. Большое сообщество

React Native имеет самое большое активное сообщество, а значит, существует множество ресурсов, библиотек и сторонних плагинов, которые помогают сократить время разработки. Если у вас возникнут какие-либо проблемы, скорее всего, вы найдете решение на Stack Overflow.

#### 3. Основываясь на имеющихся знаниях о React

Если вы уже знакомы с React, вы легко освоите React Native и сможете создавать мобильные приложения. Архитектура на основе компонентов и использование JavaScript упрощают переход от веб-разработки к мобильной.

#### 4. Производительность и пользовательский опыт на уровне нативных приложений

React Native не стал бы таким популярным, если бы не обеспечивал производительность и пользовательский опыт на уровне нативных приложений. С помощью React Native создано множество приложений, таких как:
* WhatsApp
* Instagram
* Facebook
* Discord
* Skype

---

## 10. Ограничения React Native

### В: Каковы ограничения React Native?

**О:**

Как и у всего во Вселенной, у React Native есть свои недостатки:

#### 1. Производительность

Хотя React Native обеспечивает производительность, близкую к нативной, особенно после внедрения новой архитектуры, она все же **не такая высокая, как у полностью нативных приложений** (и даже у Flutter).

**Это особенно заметно при работе с:**
* Сложной анимацией
* Ресурсоемкими вычислениями
* Обработкой видео в реальном времени
* Сложными жестами и взаимодействиями

#### 2. Ад зависимостей

Управление зависимостями в проектах React Native — это то, о чем мечтает каждый разработчик, но эта мечта оборачивается кошмаром!

**Проблемы:**
* При обновлении до новой версии React Native (или Expo) необходимо убедиться, что все зависимости совместимы
* Может оказаться утомительным и трудоемким процессом
* Иногда растягивается на несколько дней из-за необходимости вносить исправления
* Конфликты версий библиотек между iOS и Android

#### 3. По-прежнему требуются знания в области нативных технологий

Все зависит от того, что именно вы разрабатываете, но если вам нужны некоторые нативные функции, такие как:
* App Clips
* Widgets
* Background Tasks
* Специфичные API устройства

**Вам придется писать нативный код — без этого никак.**

#### 4. Не универсальное решение

Несмотря на то, что React Native — это кроссплатформенный фреймворк, он не является универсальным решением для всех задач мобильной разработки.

**Лучше всего подходит для:**
* Команд, которые уже знакомы с React
* Проектов, требующих быстрого выполнения
* Приложений средней сложности

**Могут быть более подходящие альтернативы для:**
* Сложных приложений, требующих обширной настройки
* Приложений с интенсивным использованием нативных функций
* Высокопроизводительных игр и графических приложений

---

## Заключение

React Native продолжает развиваться и с внедрением новой архитектуры становится всё более производительным и надёжным решением для кроссплатформенной мобильной разработки. Однако важно понимать его ограничения и знать, когда стоит использовать нативную разработку вместо React Native.

### Ключевые выводы:

1. **Новая архитектура** устраняет основные проблемы производительности старой архитектуры
2. **Expo** упрощает разработку, но React Native CLI даёт больше контроля
3. **Нативные модули** всё ещё необходимы для некоторых функций
4. **Производительность** близка к нативной, но не идентична
5. **Сообщество** — одно из самых больших преимуществ экосистемы

---

**Конец справочника**
